$OpenBSD: patch-src_hotspot_cpu_aarch64_c1_LIRAssembler_aarch64_cpp,v 1.1 2021/10/31 21:16:41 kurt Exp $

Fix implicit conversion failures from:
	intptr_t -> int64_t

Index: src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
--- src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp.orig
+++ src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
@@ -205,7 +205,7 @@ Address LIR_Assembler::as_Address(LIR_Address* addr, R
     if (Address::offset_ok_for_immed(addr_offset, addr->scale()))
       return Address(base, addr_offset, Address::lsl(addr->scale()));
     else {
-      __ mov(tmp, addr_offset);
+      __ mov(tmp, (int64_t)addr_offset);
       return Address(base, tmp, Address::lsl(addr->scale()));
     }
   }
@@ -566,7 +566,7 @@ void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr des
 
     case T_LONG: {
       assert(patch_code == lir_patch_none, "no patching handled here");
-      __ mov(dest->as_register_lo(), (intptr_t)c->as_jlong());
+      __ mov(dest->as_register_lo(), (int64_t)c->as_jlong());
       break;
     }
 
@@ -651,7 +651,7 @@ void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr d
         __ str(zr, frame_map()->address_for_slot(dest->double_stack_ix(),
                                                  lo_word_offset_in_bytes));
       else {
-        __ mov(rscratch1, (intptr_t)c->as_jlong_bits());
+        __ mov(rscratch1, (int64_t)c->as_jlong_bits());
         __ str(rscratch1, frame_map()->address_for_slot(dest->double_stack_ix(),
                                                         lo_word_offset_in_bytes));
       }
@@ -2005,7 +2005,7 @@ void LIR_Assembler::comp_op(LIR_Condition condition, L
           __ cmp(reg1, imm);
         return;
       } else {
-        __ mov(rscratch1, imm);
+        __ mov(rscratch1, (int64_t)imm);
         if (is_32bit)
           __ cmpw(reg1, rscratch1);
         else

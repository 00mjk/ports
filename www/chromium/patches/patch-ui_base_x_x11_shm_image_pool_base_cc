$OpenBSD: patch-ui_base_x_x11_shm_image_pool_base_cc,v 1.1 2019/12/15 12:03:47 robert Exp $

Index: ui/base/x/x11_shm_image_pool_base.cc
--- ui/base/x/x11_shm_image_pool_base.cc.orig
+++ ui/base/x/x11_shm_image_pool_base.cc
@@ -40,7 +40,7 @@ constexpr float kShmResizeShrinkThreshold =
 
 std::size_t MaxShmSegmentSizeImpl() {
   struct shminfo info;
-  if (shmctl(0, IPC_INFO, reinterpret_cast<struct shmid_ds*>(&info)) == -1)
+  if (shmctl(0, IPC_STAT, reinterpret_cast<struct shmid_ds*>(&info)) == -1)
     return 0;
   return info.shmmax;
 }
@@ -139,7 +139,7 @@ bool XShmImagePoolBase::Resize(const gfx::Size& pixel_
         shmctl(state.shminfo_.shmid, IPC_RMID, 0);
         return false;
       }
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       // On Linux, a shmid can still be attached after IPC_RMID if otherwise
       // kept alive.  Detach before XShmAttach to prevent a memory leak in case
       // the process dies.
@@ -149,7 +149,7 @@ bool XShmImagePoolBase::Resize(const gfx::Size& pixel_
       if (!XShmAttach(display_, &state.shminfo_))
         return false;
       state.shmem_attached_to_server_ = true;
-#if !defined(OS_LINUX)
+#if !defined(OS_LINUX) && !defined(OS_BSD)
       // The Linux-specific shmctl behavior above may not be portable, so we're
       // forced to do IPC_RMID after the server has attached to the segment.
       // XShmAttach is asynchronous, so we must also sync.

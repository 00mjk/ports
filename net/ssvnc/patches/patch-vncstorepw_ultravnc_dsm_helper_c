$OpenBSD: patch-vncstorepw_ultravnc_dsm_helper_c,v 1.3 2022/01/13 11:00:17 tb Exp $

LibreSSL 2.3 gets rid of SHA-0 (EVP_sha).

OpenSSL has no targetted way to disable this, thus OPENSSL_NO_SHA0 is
LibreSSL-only at present.

Build fix for opaque EVP_* based on Debian's patch
https://sources.debian.org/patches/ssvnc/1.0.29-5/openssl1.1.patch/

Index: vncstorepw/ultravnc_dsm_helper.c
--- vncstorepw/ultravnc_dsm_helper.c.orig
+++ vncstorepw/ultravnc_dsm_helper.c
@@ -413,8 +413,10 @@ void enc_do(char *ciph, char *keyfile, char *lport, ch
 		p++;
 		if (strstr(p, "md5+") == p) {
 			Digest = EVP_md5();        p += strlen("md5+");
+#ifndef OPENSSL_NO_SHA0
 		} else if (strstr(p, "sha+") == p) {
 			Digest = EVP_sha();        p += strlen("sha+");
+#endif
 		} else if (strstr(p, "sha1+") == p) {
 			Digest = EVP_sha1();       p += strlen("sha1+");
 		} else if (strstr(p, "ripe+") == p) {
@@ -655,7 +657,6 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 	 */
 	unsigned char E_keystr[EVP_MAX_KEY_LENGTH];
 	unsigned char D_keystr[EVP_MAX_KEY_LENGTH];
-	EVP_CIPHER_CTX E_ctx, D_ctx;
 	EVP_CIPHER_CTX *ctx = NULL;
 
 	unsigned char buf[BSIZE], out[BSIZE];
@@ -697,12 +698,15 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 	encstr = encrypt ? "encrypt" : "decrypt";  /* string for messages */
 	encsym = encrypt ? "+" : "-";
 
+	if ((ctx = EVP_CIPHER_CTX_new()) == NULL) {
+		fprintf(stderr, "EVP_CIPHER_CTX_new failed.\n");
+		goto finished;
+	}
+
 	/* use the encryption/decryption context variables below */
 	if (encrypt) {
-		ctx = &E_ctx;
 		keystr = E_keystr;
 	} else {
-		ctx = &D_ctx;
 		keystr = D_keystr;
 	}
 
@@ -797,7 +801,6 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 		if (whoops) {
 			fprintf(stderr, "%s: %s - WARNING: MSRC4 mode and IGNORING random salt\n", prog, encstr);
 			fprintf(stderr, "%s: %s - WARNING: and initialization vector!!\n", prog, encstr);
-			EVP_CIPHER_CTX_init(ctx);
 			if (pw_in) {
 			    /* for pw=xxxx a md5 hash is used */
 			    EVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,
@@ -836,9 +839,9 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 			in_salt = salt;
 		}
 
-		if (ivec_size < Cipher->iv_len && !securevnc) {
+		if (ivec_size < EVP_CIPHER_iv_length(Cipher) && !securevnc) {
 			fprintf(stderr, "%s: %s - WARNING: short IV %d < %d\n",
-			    prog, encstr, ivec_size, Cipher->iv_len);
+			    prog, encstr, ivec_size, EVP_CIPHER_iv_length(Cipher));
 		}
 
 		/* make the hashed value and place in keystr */
@@ -877,10 +880,6 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 		}
 
 
-		/* initialize the context */
-		EVP_CIPHER_CTX_init(ctx);
-
-
 		/* set the cipher & initialize */
 
 		/*
@@ -1005,6 +1004,8 @@ static void enc_xfer(int sock_fr, int sock_to, int enc
 			    prog, (int) getpid(), encstr, (int) parent);
 		}
 	}
+
+	EVP_CIPHER_CTX_free(ctx);
 }
 
 static int securevnc_server_rsa_save_dialog(char *file, char *md5str, unsigned char* rsabuf) {
@@ -1060,14 +1061,16 @@ static int securevnc_server_rsa_save_dialog(char *file
 }
 
 static char *rsa_md5_sum(unsigned char* rsabuf) {
-	EVP_MD_CTX md;
+	EVP_MD_CTX *md;
 	char digest[EVP_MAX_MD_SIZE], tmp[16];
 	char md5str[EVP_MAX_MD_SIZE * 8];
 	unsigned int i, size = 0;
 
-	EVP_DigestInit(&md, EVP_md5());
-	EVP_DigestUpdate(&md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);
-	EVP_DigestFinal(&md, (unsigned char *)digest, &size);
+	md = EVP_MD_CTX_new();
+	EVP_DigestInit(md, EVP_md5());
+	EVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);
+	EVP_DigestFinal(md, (unsigned char *)digest, &size);
+	EVP_MD_CTX_free(md);
 
 	memset(md5str, 0, sizeof(md5str));
 	for (i=0; i < size; i++) {
@@ -1184,7 +1187,7 @@ static void sslexit(char *msg) {
 
 static void securevnc_setup(int conn1, int conn2) {
 	RSA *rsa = NULL;
-	EVP_CIPHER_CTX init_ctx;
+	EVP_CIPHER_CTX *init_ctx;
 	unsigned char keystr[EVP_MAX_KEY_LENGTH];
 	unsigned char *rsabuf, *rsasav;
 	unsigned char *encrypted_keybuf;
@@ -1203,6 +1206,11 @@ static void securevnc_setup(int conn1, int conn2) {
 
 	ERR_load_crypto_strings();
 
+	if ((init_ctx = EVP_CIPHER_CTX_new()) == NULL) {
+		fprintf(stderr, "securevnc_setup: EVP_CIPHER_CTX_new failed.\n");
+		exit(1);
+	}
+
 	/* alloc and read from server the 270 comprising the rsa public key: */
 	rsabuf = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);
 	rsasav = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);
@@ -1323,8 +1331,7 @@ static void securevnc_setup(int conn1, int conn2) {
 	/*
 	 * Back to the work involving the tmp obscuring key:
 	 */
-	EVP_CIPHER_CTX_init(&init_ctx);
-	rc = EVP_CipherInit_ex(&init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);
+	rc = EVP_CipherInit_ex(init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);
 	if (rc == 0) {
 		sslexit("securevnc_setup: EVP_CipherInit_ex(init_ctx) failed");
 	}
@@ -1340,13 +1347,13 @@ static void securevnc_setup(int conn1, int conn2) {
 	/* decode with the tmp key */
 	if (n > 0) {
 		memset(to_viewer, 0, sizeof(to_viewer));
-		if (EVP_CipherUpdate(&init_ctx, to_viewer, &len, buf, n) == 0) {
+		if (EVP_CipherUpdate(init_ctx, to_viewer, &len, buf, n) == 0) {
 			sslexit("securevnc_setup: EVP_CipherUpdate(init_ctx) failed");
 			exit(1);
 		}
 		to_viewer_len = len;
 	}
-	EVP_CIPHER_CTX_cleanup(&init_ctx);
+	EVP_CIPHER_CTX_free(init_ctx);
 	free(initkey);
 
 	/* print what we would send to the viewer (sent below): */
@@ -1407,7 +1414,7 @@ static void securevnc_setup(int conn1, int conn2) {
 
 	if (client_auth_req && client_auth) {
 		RSA *client_rsa = load_client_auth(client_auth);
-		EVP_MD_CTX dctx;
+		EVP_MD_CTX *dctx;
 		unsigned char digest[EVP_MAX_MD_SIZE], *signature;
 		unsigned int ndig = 0, nsig = 0;
 
@@ -1421,8 +1428,13 @@ static void securevnc_setup(int conn1, int conn2) {
 			exit(1);
 		}
 
-		EVP_DigestInit(&dctx, EVP_sha1());
-		EVP_DigestUpdate(&dctx, keystr, SECUREVNC_KEY_SIZE);
+		if ((dctx = EVP_MD_CTX_new()) == NULL) {
+			fprintf(stderr, "securevnc_setup: EVP_MD_CTX_new failed.\n");
+			exit(1);
+		}
+
+		EVP_DigestInit(dctx, EVP_sha1());
+		EVP_DigestUpdate(dctx, keystr, SECUREVNC_KEY_SIZE);
 		/*
 		 * Without something like the following MITM is still possible.
 		 * This is because the MITM knows keystr and can use it with
@@ -1433,7 +1445,7 @@ static void securevnc_setup(int conn1, int conn2) {
 		 * he doesn't have Viewer_ClientAuth.pkey.
 		 */
 		if (0) {
-			EVP_DigestUpdate(&dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);
+			EVP_DigestUpdate(dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);
 			if (!keystore_verified) {
 				fprintf(stderr, "securevnc_setup:\n");
 				fprintf(stderr, "securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\n");
@@ -1456,7 +1468,7 @@ static void securevnc_setup(int conn1, int conn2) {
 				fprintf(stderr, "securevnc_setup:\n");
 			}
 		}
-		EVP_DigestFinal(&dctx, (unsigned char *)digest, &ndig);
+		EVP_DigestFinal(dctx, (unsigned char *)digest, &ndig);
 
 		signature = (unsigned char *) calloc(RSA_size(client_rsa), 1);
 		RSA_sign(NID_sha1, digest, ndig, signature, &nsig, client_rsa);
@@ -1466,6 +1478,7 @@ static void securevnc_setup(int conn1, int conn2) {
 		free(signature);
 
 		RSA_free(client_rsa);
+		EVP_MD_CTX_free(dctx);
 	}
 
 	fprintf(stderr, "securevnc_setup: done.\n");
